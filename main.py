# Copyright (c) 2016 John Donovan
#
# Released under the MIT License (MIT)
# See the LICENSE file, or visit http://opensource.org/licenses/MIT

"""
Generates a LilyPond file of Rob Miles's chiptune algorithm:

echo "g(i,x,t,o){return((3&x&(i*((3&i>>16?\"BY}6YB6%\":\"Qj}6jQ6%\")[t%8]+51)>>o))<<4);};
main(i,n,s){for(i=0;;i++)putchar(g(i,1,n=i>>14,12)+g(i,s=i>>17,n^i>>13,10)+g(i,s/3,n+((i>>
11)%3),10)+g(i,s/5,8+n-((i>>10)%3),9));}"|gcc -xc -&&./a.out|aplay

See: https://www.youtube.com/watch?v=MqZgoNRERY8

I've not tried very hard to optimise this, or even to produce elegant code.
"""

import os
from collections import deque
from jinja2 import FileSystemLoader, Environment

# Set up the Jinja2 template.
j2_env = Environment(loader=FileSystemLoader(os.path.dirname(os.path.abspath(__file__))))

# The note table is geared for keys with all flats - c minor in the default tune. LilyPond will mark a note as an
# accidental if the flatness or sharpness doesn't agree with the stave. Any audio output will still sound OK, but don't
# expect a pianist to like you if you ask them to play it.
# I use a reverse dictionary lookup to match a frequency to the nearest note. This is because the frequencies
# generated by the algorithm aren't always exactly concert pitch.
note_table = {
    "c'''''": 4186.01,
    "b''''": 3951.07,
    "bf''''": 3729.31,
    "a''''": 3520,
    "af''''": 3322.44,
    "g''''": 3135.96,
    "gf''''": 2959.96,
    "f''''": 2793.83,
    "e''''": 2637.02,
    "ef''''": 2489.02,
    "d''''": 2349.32,
    "df''''": 2217.46,
    "c''''": 2093,
    "b'''": 1975.53,
    "bf'''": 1864.66,
    "a'''": 1760,
    "af'''": 1661.22,
    "g'''": 1567.98,
    "gf'''": 1479.98,
    "f'''": 1396.91,
    "e'''": 1318.51,
    "ef'''": 1244.51,
    "d'''": 1174.66,
    "df'''": 1108.73,
    "c'''": 1046.5,
    "b''": 987.767,
    "bf''": 932.328,
    "a''": 880,
    "af''": 830.609,
    "g''": 783.991,
    "gf''": 739.989,
    "f''": 698.456,
    "e''": 659.255,
    "ef''": 622.254,
    "d''": 587.33,
    "df''": 554.365,
    "c''": 523.251,
    "b'": 493.883,
    "bf'": 466.164,
    "a'": 440,
    "af'": 415.305,
    "g'": 391.995,
    "gf'": 369.994,
    "f'": 349.228,
    "e'": 329.628,
    "ef'": 311.127,
    "d'": 293.665,
    "df'": 277.183,
    "c'": 261.626,
    "b": 246.942,
    "bf": 233.082,
    "a": 220,
    "af": 207.652,
    "g": 195.998,
    "gf": 184.997,
    "f": 174.614,
    "e": 164.814,
    "ef": 155.563,
    "d": 146.832,
    "df": 138.591,
    "c": 130.813,
    "b,": 123.471,
    "bf,": 116.541,
    "a,": 110,
    "af,": 103.826,
    "g,": 97.9989,
    "gf,": 92.4986,
    "f,": 87.3071,
    "e,": 82.4069,
    "ef,": 77.7817,
    "d,": 73.4162,
    "df,": 69.2957,
    "c,": 65.4064,
    "b,,": 61.7354,
    "bf,,": 58.2705,
    "a,,": 55,
    "af,,": 51.9131,
    "g,,": 48.9994,
    "gf,,": 46.2493,
    "f,,": 43.6535,
    "e,,": 41.2034,
    "ef,,": 38.8909,
    "d,,": 36.7081,
    "df,,": 34.6478,
    "c,,": 32.7032,
    "b,,,": 30.8677,
    "bf,,,": 29.1352,
    "a,,,": 27.5
}

# These represent the two base melodies. They can be changed to produce different tunes, but must always be 8 characters
# long, otherwise Bad Things will happen. Rob says in a YouTube comment (https://www.youtube.com/watch?v=MqZgoNRERY8):
# "But if you want to make something actually musical, stick to using the characters
# %, *, 0, 6, <, B, I, Q, Y, a, j, s, and }, as those correspond to actual notes (an octave of semitones from G to G)."
PART_A = 'BY}6YB6%'
PART_B = 'Qj}6jQ6%'

prev_tick = -1
tick = -1
notes = [deque(), deque(), deque(), deque()]


def gen_pitch(clock, time):
    """
    Generates the frequency for the current voice's note.
    :param clock: The master clock.
    :param time: The time of the current voice.
    :return: A frequency in Hz
    """
    part = PART_A if (3 & clock >> 16) else PART_B
    n = part[time % 8]

    return ord(n) + 51


def g(clock, section, time, octave, voice):
    """
    Produce a deque of note values at a resolution of semiquavers for each voice and part.
    :param clock:
    :param section:
    :param time:
    :param octave:
    :param voice:
    :return:
    """
    global tick
    global prev_tick
    pitch = gen_pitch(clock, time)
    section &= 3

    o = 12 - octave

    if prev_tick != tick:
        if section == 0:
            notes[voice].append('r')
        elif section == 1:
            freq = pitch * (1 << o)
            # This is a reverse dictionary lookup to find the note nearest to the generated frequency.
            note, _ = min(note_table.items(), key=lambda v: abs(v[1] - freq))
            notes[voice].append(note)
        elif section == 2:
            freq = (pitch * (1 << o)) >> 1
            note, _ = min(note_table.items(), key=lambda v: abs(v[1] - freq))
            notes[voice].append(note)
        elif section == 3:
            freq1 = pitch * (1 << o)
            freq2 = (pitch * (1 << o)) >> 1
            note1, _ = min(note_table.items(), key=lambda v: abs(v[1] - freq1))
            note2, _ = min(note_table.items(), key=lambda v: abs(v[1] - freq2))
            # Part 3 produces a simple octave chord.
            notes[voice].append('<{0} {1}>'.format(note1, note2))


def main():
    global tick
    global prev_tick

    clock = 0
    bar = 0

    # 160 bars is the length of the longest voice.
    while bar < 160:
        bar = clock >> 14
        s = clock >> 17
        prev_tick = (clock >> 10)
        g(clock, 1, bar, 12, 0)
        g(clock, s, bar ^ clock >> 13, 10, 1)
        g(clock, s // 3, bar + ((clock >> 11) % 3), 10, 2)
        g(clock, s // 5, 8 + bar - ((clock >> 10) % 3), 9, 3)

        clock += 1
        tick = prev_tick

    # Once the note values have been created, we smush them together to form longer durations. We throw away any notes
    # beyond the number of bars for that voice. This was determined empirically, but I'm sure there's some cool maths
    # you could do to calculate this.
    out = [consolidate(notes[0], 16),
           consolidate(notes[1], 32),
           consolidate(notes[2], 96),
           consolidate(notes[3], 160)]

    # Chuck the finished LilyPond file out to stdout.
    print(j2_env.get_template('bitshift_variations.ly.template').render(voice=out))


def consolidate(voice, length):
    """
    Join notes of the same pitch together, and increase their duration. No attempt is made to handle ties between bars,
    They are just treated as separate notes.

    :param voice:
    :param length:
    :return:
    """
    out = list()

    try:
        for bars in range(0, length):
            duration = 1
            prev_n = voice.popleft()

            for i in range(1, 16):
                n = voice.popleft()

                if n == prev_n:
                    duration += 1
                else:
                    out.append('{0}{1}'.format(prev_n, 16 // duration))
                    duration = 1

                prev_n = n

            out.append('{0}{1}'.format(prev_n, 16 // duration))

        return out

    except IndexError:
        return out

if __name__ == '__main__':
    main()
